/*
Vimeo API

Build something great. Vimeo's API supports flexible, high-quality video integration with your custom apps.

API version: 3.4
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package vimeoapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


type LiveEventM3U8PlaybackAPI interface {

	/*
	GetLiveEventM3u8Playback Get an M3U8 playback URL for a live event

	This method returns an M3U8 playback URL for the specified event stream. You should use this endpoint only in conjunction with our recommended procedure for playing events via HLS. For more information, see our [HLS guide](https://developer.vimeo.com/api/live/playback).

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param liveEventId The ID of the event.
	@param userId The ID of the user.
	@return ApiGetLiveEventM3u8PlaybackRequest
	*/
	GetLiveEventM3u8Playback(ctx context.Context, liveEventId float32, userId float32) ApiGetLiveEventM3u8PlaybackRequest

	// GetLiveEventM3u8PlaybackExecute executes the request
	GetLiveEventM3u8PlaybackExecute(r ApiGetLiveEventM3u8PlaybackRequest) (*http.Response, error)

	/*
	GetLiveEventM3u8PlaybackAlt1 Get an M3U8 playback URL for a live event

	This method returns an M3U8 playback URL for the specified event stream. You should use this endpoint only in conjunction with our recommended procedure for playing events via HLS. For more information, see our [HLS guide](https://developer.vimeo.com/api/live/playback).

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param liveEventId The ID of the event.
	@return ApiGetLiveEventM3u8PlaybackAlt1Request
	*/
	GetLiveEventM3u8PlaybackAlt1(ctx context.Context, liveEventId float32) ApiGetLiveEventM3u8PlaybackAlt1Request

	// GetLiveEventM3u8PlaybackAlt1Execute executes the request
	GetLiveEventM3u8PlaybackAlt1Execute(r ApiGetLiveEventM3u8PlaybackAlt1Request) (*http.Response, error)
}

// LiveEventM3U8PlaybackAPIService LiveEventM3U8PlaybackAPI service
type LiveEventM3U8PlaybackAPIService service

type ApiGetLiveEventM3u8PlaybackRequest struct {
	ctx context.Context
	ApiService LiveEventM3U8PlaybackAPI
	liveEventId float32
	userId float32
	maxFpsFhd *float32
}

// The requested maximum frames per second.
func (r ApiGetLiveEventM3u8PlaybackRequest) MaxFpsFhd(maxFpsFhd float32) ApiGetLiveEventM3u8PlaybackRequest {
	r.maxFpsFhd = &maxFpsFhd
	return r
}

func (r ApiGetLiveEventM3u8PlaybackRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetLiveEventM3u8PlaybackExecute(r)
}

/*
GetLiveEventM3u8Playback Get an M3U8 playback URL for a live event

This method returns an M3U8 playback URL for the specified event stream. You should use this endpoint only in conjunction with our recommended procedure for playing events via HLS. For more information, see our [HLS guide](https://developer.vimeo.com/api/live/playback).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param liveEventId The ID of the event.
 @param userId The ID of the user.
 @return ApiGetLiveEventM3u8PlaybackRequest
*/
func (a *LiveEventM3U8PlaybackAPIService) GetLiveEventM3u8Playback(ctx context.Context, liveEventId float32, userId float32) ApiGetLiveEventM3u8PlaybackRequest {
	return ApiGetLiveEventM3u8PlaybackRequest{
		ApiService: a,
		ctx: ctx,
		liveEventId: liveEventId,
		userId: userId,
	}
}

// Execute executes the request
func (a *LiveEventM3U8PlaybackAPIService) GetLiveEventM3u8PlaybackExecute(r ApiGetLiveEventM3u8PlaybackRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveEventM3U8PlaybackAPIService.GetLiveEventM3u8Playback")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_id}/live_events/{live_event_id}/m3u8_playback"
	localVarPath = strings.Replace(localVarPath, "{"+"live_event_id"+"}", url.PathEscape(parameterValueToString(r.liveEventId, "liveEventId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.maxFpsFhd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_fps_fhd", r.maxFpsFhd, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetLiveEventM3u8PlaybackAlt1Request struct {
	ctx context.Context
	ApiService LiveEventM3U8PlaybackAPI
	liveEventId float32
	maxFpsFhd *float32
}

// The requested maximum frames per second.
func (r ApiGetLiveEventM3u8PlaybackAlt1Request) MaxFpsFhd(maxFpsFhd float32) ApiGetLiveEventM3u8PlaybackAlt1Request {
	r.maxFpsFhd = &maxFpsFhd
	return r
}

func (r ApiGetLiveEventM3u8PlaybackAlt1Request) Execute() (*http.Response, error) {
	return r.ApiService.GetLiveEventM3u8PlaybackAlt1Execute(r)
}

/*
GetLiveEventM3u8PlaybackAlt1 Get an M3U8 playback URL for a live event

This method returns an M3U8 playback URL for the specified event stream. You should use this endpoint only in conjunction with our recommended procedure for playing events via HLS. For more information, see our [HLS guide](https://developer.vimeo.com/api/live/playback).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param liveEventId The ID of the event.
 @return ApiGetLiveEventM3u8PlaybackAlt1Request
*/
func (a *LiveEventM3U8PlaybackAPIService) GetLiveEventM3u8PlaybackAlt1(ctx context.Context, liveEventId float32) ApiGetLiveEventM3u8PlaybackAlt1Request {
	return ApiGetLiveEventM3u8PlaybackAlt1Request{
		ApiService: a,
		ctx: ctx,
		liveEventId: liveEventId,
	}
}

// Execute executes the request
func (a *LiveEventM3U8PlaybackAPIService) GetLiveEventM3u8PlaybackAlt1Execute(r ApiGetLiveEventM3u8PlaybackAlt1Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveEventM3U8PlaybackAPIService.GetLiveEventM3u8PlaybackAlt1")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/live_events/{live_event_id}/m3u8_playback"
	localVarPath = strings.Replace(localVarPath, "{"+"live_event_id"+"}", url.PathEscape(parameterValueToString(r.liveEventId, "liveEventId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.maxFpsFhd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_fps_fhd", r.maxFpsFhd, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
