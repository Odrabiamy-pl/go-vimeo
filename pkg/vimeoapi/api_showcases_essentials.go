/*
Vimeo API

Build something great. Vimeo's API supports flexible, high-quality video integration with your custom apps.

API version: 3.4
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package vimeoapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


type ShowcasesEssentialsAPI interface {

	/*
	CreateShowcase Create a showcase

	This method creates a new showcase for the specified user.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userId The ID of the user.
	@return ApiCreateShowcaseRequest
	*/
	CreateShowcase(ctx context.Context, userId int32) ApiCreateShowcaseRequest

	// CreateShowcaseExecute executes the request
	//  @return Album
	CreateShowcaseExecute(r ApiCreateShowcaseRequest) (*Album, *http.Response, error)

	/*
	CreateShowcaseAlt1 Create a showcase

	This method creates a new showcase for the specified user.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCreateShowcaseAlt1Request
	*/
	CreateShowcaseAlt1(ctx context.Context) ApiCreateShowcaseAlt1Request

	// CreateShowcaseAlt1Execute executes the request
	//  @return Album
	CreateShowcaseAlt1Execute(r ApiCreateShowcaseAlt1Request) (*Album, *http.Response, error)

	/*
	DeleteShowcase Delete a showcase

	This method deletes the specified showcase. The authenticated user must be the owner of the showcase.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param albumId The ID of the showcase.
	@param userId The ID of the user.
	@return ApiDeleteShowcaseRequest
	*/
	DeleteShowcase(ctx context.Context, albumId float32, userId int32) ApiDeleteShowcaseRequest

	// DeleteShowcaseExecute executes the request
	DeleteShowcaseExecute(r ApiDeleteShowcaseRequest) (*http.Response, error)

	/*
	DeleteShowcaseAlt2 Delete a showcase

	This method deletes the specified showcase. The authenticated user must be the owner of the showcase.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param albumId The ID of the showcase.
	@return ApiDeleteShowcaseAlt2Request
	*/
	DeleteShowcaseAlt2(ctx context.Context, albumId float32) ApiDeleteShowcaseAlt2Request

	// DeleteShowcaseAlt2Execute executes the request
	DeleteShowcaseAlt2Execute(r ApiDeleteShowcaseAlt2Request) (*http.Response, error)

	/*
	EditShowcase Edit a showcase

	This method edits the specified showcase. The authenticated user must be the owner of the showcase.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param albumId The ID of the showcase.
	@param userId The ID of the user.
	@return ApiEditShowcaseRequest
	*/
	EditShowcase(ctx context.Context, albumId float32, userId int32) ApiEditShowcaseRequest

	// EditShowcaseExecute executes the request
	//  @return Album
	EditShowcaseExecute(r ApiEditShowcaseRequest) (*Album, *http.Response, error)

	/*
	EditShowcaseAlt2 Edit a showcase

	This method edits the specified showcase. The authenticated user must be the owner of the showcase.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param albumId The ID of the showcase.
	@return ApiEditShowcaseAlt2Request
	*/
	EditShowcaseAlt2(ctx context.Context, albumId float32) ApiEditShowcaseAlt2Request

	// EditShowcaseAlt2Execute executes the request
	//  @return Album
	EditShowcaseAlt2Execute(r ApiEditShowcaseAlt2Request) (*Album, *http.Response, error)

	/*
	GetShowcase Get a specific showcase

	This method returns the specified showcase. The authenticated user must be the owner of the showcase.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param albumId The ID of the showcase.
	@param userId The ID of the user.
	@return ApiGetShowcaseRequest
	*/
	GetShowcase(ctx context.Context, albumId float32, userId int32) ApiGetShowcaseRequest

	// GetShowcaseExecute executes the request
	//  @return Album
	GetShowcaseExecute(r ApiGetShowcaseRequest) (*Album, *http.Response, error)

	/*
	GetShowcaseAlt2 Get a specific showcase

	This method returns the specified showcase. The authenticated user must be the owner of the showcase.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param albumId The ID of the showcase.
	@return ApiGetShowcaseAlt2Request
	*/
	GetShowcaseAlt2(ctx context.Context, albumId float32) ApiGetShowcaseAlt2Request

	// GetShowcaseAlt2Execute executes the request
	//  @return Album
	GetShowcaseAlt2Execute(r ApiGetShowcaseAlt2Request) (*Album, *http.Response, error)

	/*
	GetShowcases Get all the showcases that belong to the user

	This method returns every showcase belonging to the authenticated user.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userId The ID of the user.
	@return ApiGetShowcasesRequest
	*/
	GetShowcases(ctx context.Context, userId int32) ApiGetShowcasesRequest

	// GetShowcasesExecute executes the request
	//  @return []Album
	GetShowcasesExecute(r ApiGetShowcasesRequest) ([]Album, *http.Response, error)

	/*
	GetShowcasesAlt1 Get all the showcases that belong to the user

	This method returns every showcase belonging to the authenticated user.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetShowcasesAlt1Request
	*/
	GetShowcasesAlt1(ctx context.Context) ApiGetShowcasesAlt1Request

	// GetShowcasesAlt1Execute executes the request
	//  @return []Album
	GetShowcasesAlt1Execute(r ApiGetShowcasesAlt1Request) ([]Album, *http.Response, error)

	/*
	UpdateShowcases Add videos and live events to showcases

	This method adds videos and events to the specified showcases. The authenticated user must either be the owner of the showcase or have team permissions.

The present setup permits only one event per showcase.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userId The ID of the user.
	@return ApiUpdateShowcasesRequest
	*/
	UpdateShowcases(ctx context.Context, userId int32) ApiUpdateShowcasesRequest

	// UpdateShowcasesExecute executes the request
	UpdateShowcasesExecute(r ApiUpdateShowcasesRequest) (*http.Response, error)
}

// ShowcasesEssentialsAPIService ShowcasesEssentialsAPI service
type ShowcasesEssentialsAPIService service

type ApiCreateShowcaseRequest struct {
	ctx context.Context
	ApiService ShowcasesEssentialsAPI
	userId int32
	createShowcaseAlt1Request *CreateShowcaseAlt1Request
}

func (r ApiCreateShowcaseRequest) CreateShowcaseAlt1Request(createShowcaseAlt1Request CreateShowcaseAlt1Request) ApiCreateShowcaseRequest {
	r.createShowcaseAlt1Request = &createShowcaseAlt1Request
	return r
}

func (r ApiCreateShowcaseRequest) Execute() (*Album, *http.Response, error) {
	return r.ApiService.CreateShowcaseExecute(r)
}

/*
CreateShowcase Create a showcase

This method creates a new showcase for the specified user.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId The ID of the user.
 @return ApiCreateShowcaseRequest
*/
func (a *ShowcasesEssentialsAPIService) CreateShowcase(ctx context.Context, userId int32) ApiCreateShowcaseRequest {
	return ApiCreateShowcaseRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
	}
}

// Execute executes the request
//  @return Album
func (a *ShowcasesEssentialsAPIService) CreateShowcaseExecute(r ApiCreateShowcaseRequest) (*Album, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Album
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ShowcasesEssentialsAPIService.CreateShowcase")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_id}/albums"
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createShowcaseAlt1Request == nil {
		return localVarReturnValue, nil, reportError("createShowcaseAlt1Request is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/vnd.vimeo.album+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.vimeo.album+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createShowcaseAlt1Request
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v LegacyError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v LegacyError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateShowcaseAlt1Request struct {
	ctx context.Context
	ApiService ShowcasesEssentialsAPI
	createShowcaseAlt1Request *CreateShowcaseAlt1Request
}

func (r ApiCreateShowcaseAlt1Request) CreateShowcaseAlt1Request(createShowcaseAlt1Request CreateShowcaseAlt1Request) ApiCreateShowcaseAlt1Request {
	r.createShowcaseAlt1Request = &createShowcaseAlt1Request
	return r
}

func (r ApiCreateShowcaseAlt1Request) Execute() (*Album, *http.Response, error) {
	return r.ApiService.CreateShowcaseAlt1Execute(r)
}

/*
CreateShowcaseAlt1 Create a showcase

This method creates a new showcase for the specified user.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateShowcaseAlt1Request
*/
func (a *ShowcasesEssentialsAPIService) CreateShowcaseAlt1(ctx context.Context) ApiCreateShowcaseAlt1Request {
	return ApiCreateShowcaseAlt1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Album
func (a *ShowcasesEssentialsAPIService) CreateShowcaseAlt1Execute(r ApiCreateShowcaseAlt1Request) (*Album, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Album
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ShowcasesEssentialsAPIService.CreateShowcaseAlt1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/albums"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createShowcaseAlt1Request == nil {
		return localVarReturnValue, nil, reportError("createShowcaseAlt1Request is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/vnd.vimeo.album+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.vimeo.album+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createShowcaseAlt1Request
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v LegacyError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v LegacyError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteShowcaseRequest struct {
	ctx context.Context
	ApiService ShowcasesEssentialsAPI
	albumId float32
	userId int32
}

func (r ApiDeleteShowcaseRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteShowcaseExecute(r)
}

/*
DeleteShowcase Delete a showcase

This method deletes the specified showcase. The authenticated user must be the owner of the showcase.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param albumId The ID of the showcase.
 @param userId The ID of the user.
 @return ApiDeleteShowcaseRequest
*/
func (a *ShowcasesEssentialsAPIService) DeleteShowcase(ctx context.Context, albumId float32, userId int32) ApiDeleteShowcaseRequest {
	return ApiDeleteShowcaseRequest{
		ApiService: a,
		ctx: ctx,
		albumId: albumId,
		userId: userId,
	}
}

// Execute executes the request
func (a *ShowcasesEssentialsAPIService) DeleteShowcaseExecute(r ApiDeleteShowcaseRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ShowcasesEssentialsAPIService.DeleteShowcase")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_id}/albums/{album_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"album_id"+"}", url.PathEscape(parameterValueToString(r.albumId, "albumId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v LegacyError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v LegacyError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteShowcaseAlt2Request struct {
	ctx context.Context
	ApiService ShowcasesEssentialsAPI
	albumId float32
}

func (r ApiDeleteShowcaseAlt2Request) Execute() (*http.Response, error) {
	return r.ApiService.DeleteShowcaseAlt2Execute(r)
}

/*
DeleteShowcaseAlt2 Delete a showcase

This method deletes the specified showcase. The authenticated user must be the owner of the showcase.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param albumId The ID of the showcase.
 @return ApiDeleteShowcaseAlt2Request
*/
func (a *ShowcasesEssentialsAPIService) DeleteShowcaseAlt2(ctx context.Context, albumId float32) ApiDeleteShowcaseAlt2Request {
	return ApiDeleteShowcaseAlt2Request{
		ApiService: a,
		ctx: ctx,
		albumId: albumId,
	}
}

// Execute executes the request
func (a *ShowcasesEssentialsAPIService) DeleteShowcaseAlt2Execute(r ApiDeleteShowcaseAlt2Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ShowcasesEssentialsAPIService.DeleteShowcaseAlt2")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/albums/{album_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"album_id"+"}", url.PathEscape(parameterValueToString(r.albumId, "albumId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v LegacyError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v LegacyError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEditShowcaseRequest struct {
	ctx context.Context
	ApiService ShowcasesEssentialsAPI
	albumId float32
	userId int32
	editShowcaseAlt2Request *EditShowcaseAlt2Request
}

func (r ApiEditShowcaseRequest) EditShowcaseAlt2Request(editShowcaseAlt2Request EditShowcaseAlt2Request) ApiEditShowcaseRequest {
	r.editShowcaseAlt2Request = &editShowcaseAlt2Request
	return r
}

func (r ApiEditShowcaseRequest) Execute() (*Album, *http.Response, error) {
	return r.ApiService.EditShowcaseExecute(r)
}

/*
EditShowcase Edit a showcase

This method edits the specified showcase. The authenticated user must be the owner of the showcase.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param albumId The ID of the showcase.
 @param userId The ID of the user.
 @return ApiEditShowcaseRequest
*/
func (a *ShowcasesEssentialsAPIService) EditShowcase(ctx context.Context, albumId float32, userId int32) ApiEditShowcaseRequest {
	return ApiEditShowcaseRequest{
		ApiService: a,
		ctx: ctx,
		albumId: albumId,
		userId: userId,
	}
}

// Execute executes the request
//  @return Album
func (a *ShowcasesEssentialsAPIService) EditShowcaseExecute(r ApiEditShowcaseRequest) (*Album, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Album
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ShowcasesEssentialsAPIService.EditShowcase")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_id}/albums/{album_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"album_id"+"}", url.PathEscape(parameterValueToString(r.albumId, "albumId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/vnd.vimeo.album+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.vimeo.album+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.editShowcaseAlt2Request
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v LegacyError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v LegacyError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v LegacyError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEditShowcaseAlt2Request struct {
	ctx context.Context
	ApiService ShowcasesEssentialsAPI
	albumId float32
	editShowcaseAlt2Request *EditShowcaseAlt2Request
}

func (r ApiEditShowcaseAlt2Request) EditShowcaseAlt2Request(editShowcaseAlt2Request EditShowcaseAlt2Request) ApiEditShowcaseAlt2Request {
	r.editShowcaseAlt2Request = &editShowcaseAlt2Request
	return r
}

func (r ApiEditShowcaseAlt2Request) Execute() (*Album, *http.Response, error) {
	return r.ApiService.EditShowcaseAlt2Execute(r)
}

/*
EditShowcaseAlt2 Edit a showcase

This method edits the specified showcase. The authenticated user must be the owner of the showcase.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param albumId The ID of the showcase.
 @return ApiEditShowcaseAlt2Request
*/
func (a *ShowcasesEssentialsAPIService) EditShowcaseAlt2(ctx context.Context, albumId float32) ApiEditShowcaseAlt2Request {
	return ApiEditShowcaseAlt2Request{
		ApiService: a,
		ctx: ctx,
		albumId: albumId,
	}
}

// Execute executes the request
//  @return Album
func (a *ShowcasesEssentialsAPIService) EditShowcaseAlt2Execute(r ApiEditShowcaseAlt2Request) (*Album, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Album
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ShowcasesEssentialsAPIService.EditShowcaseAlt2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/albums/{album_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"album_id"+"}", url.PathEscape(parameterValueToString(r.albumId, "albumId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/vnd.vimeo.album+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.vimeo.album+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.editShowcaseAlt2Request
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v LegacyError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v LegacyError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v LegacyError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetShowcaseRequest struct {
	ctx context.Context
	ApiService ShowcasesEssentialsAPI
	albumId float32
	userId int32
}

func (r ApiGetShowcaseRequest) Execute() (*Album, *http.Response, error) {
	return r.ApiService.GetShowcaseExecute(r)
}

/*
GetShowcase Get a specific showcase

This method returns the specified showcase. The authenticated user must be the owner of the showcase.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param albumId The ID of the showcase.
 @param userId The ID of the user.
 @return ApiGetShowcaseRequest
*/
func (a *ShowcasesEssentialsAPIService) GetShowcase(ctx context.Context, albumId float32, userId int32) ApiGetShowcaseRequest {
	return ApiGetShowcaseRequest{
		ApiService: a,
		ctx: ctx,
		albumId: albumId,
		userId: userId,
	}
}

// Execute executes the request
//  @return Album
func (a *ShowcasesEssentialsAPIService) GetShowcaseExecute(r ApiGetShowcaseRequest) (*Album, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Album
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ShowcasesEssentialsAPIService.GetShowcase")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_id}/albums/{album_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"album_id"+"}", url.PathEscape(parameterValueToString(r.albumId, "albumId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.vimeo.album+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v LegacyError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetShowcaseAlt2Request struct {
	ctx context.Context
	ApiService ShowcasesEssentialsAPI
	albumId float32
}

func (r ApiGetShowcaseAlt2Request) Execute() (*Album, *http.Response, error) {
	return r.ApiService.GetShowcaseAlt2Execute(r)
}

/*
GetShowcaseAlt2 Get a specific showcase

This method returns the specified showcase. The authenticated user must be the owner of the showcase.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param albumId The ID of the showcase.
 @return ApiGetShowcaseAlt2Request
*/
func (a *ShowcasesEssentialsAPIService) GetShowcaseAlt2(ctx context.Context, albumId float32) ApiGetShowcaseAlt2Request {
	return ApiGetShowcaseAlt2Request{
		ApiService: a,
		ctx: ctx,
		albumId: albumId,
	}
}

// Execute executes the request
//  @return Album
func (a *ShowcasesEssentialsAPIService) GetShowcaseAlt2Execute(r ApiGetShowcaseAlt2Request) (*Album, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Album
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ShowcasesEssentialsAPIService.GetShowcaseAlt2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/albums/{album_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"album_id"+"}", url.PathEscape(parameterValueToString(r.albumId, "albumId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.vimeo.album+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v LegacyError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetShowcasesRequest struct {
	ctx context.Context
	ApiService ShowcasesEssentialsAPI
	userId int32
	direction *string
	page *float32
	perPage *float32
	query *string
	sort *string
}

// The sort direction of the results.  Option descriptions:  * &#x60;asc&#x60; - Sort the results in ascending order.  * &#x60;desc&#x60; - Sort the results in descending order. 
func (r ApiGetShowcasesRequest) Direction(direction string) ApiGetShowcasesRequest {
	r.direction = &direction
	return r
}

// The page number of the results to show.
func (r ApiGetShowcasesRequest) Page(page float32) ApiGetShowcasesRequest {
	r.page = &page
	return r
}

// The number of items to show on each page of results, up to a maximum of 100.
func (r ApiGetShowcasesRequest) PerPage(perPage float32) ApiGetShowcasesRequest {
	r.perPage = &perPage
	return r
}

// The search query to use to filter the results.
func (r ApiGetShowcasesRequest) Query(query string) ApiGetShowcasesRequest {
	r.query = &query
	return r
}

// The way to sort the results.  Option descriptions:  * &#x60;alphabetical&#x60; - Sort the results alphabetically.  * &#x60;date&#x60; - Sort the results by date of creation.  * &#x60;duration&#x60; - Sort the results by duration.  * &#x60;videos&#x60; - Sort the results by the number of videos. 
func (r ApiGetShowcasesRequest) Sort(sort string) ApiGetShowcasesRequest {
	r.sort = &sort
	return r
}

func (r ApiGetShowcasesRequest) Execute() ([]Album, *http.Response, error) {
	return r.ApiService.GetShowcasesExecute(r)
}

/*
GetShowcases Get all the showcases that belong to the user

This method returns every showcase belonging to the authenticated user.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId The ID of the user.
 @return ApiGetShowcasesRequest
*/
func (a *ShowcasesEssentialsAPIService) GetShowcases(ctx context.Context, userId int32) ApiGetShowcasesRequest {
	return ApiGetShowcasesRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
	}
}

// Execute executes the request
//  @return []Album
func (a *ShowcasesEssentialsAPIService) GetShowcasesExecute(r ApiGetShowcasesRequest) ([]Album, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Album
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ShowcasesEssentialsAPIService.GetShowcases")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_id}/albums"
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.direction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "direction", r.direction, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.perPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "per_page", r.perPage, "")
	}
	if r.query != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "query", r.query, "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v LegacyError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetShowcasesAlt1Request struct {
	ctx context.Context
	ApiService ShowcasesEssentialsAPI
	direction *string
	page *float32
	perPage *float32
	query *string
	sort *string
}

// The sort direction of the results.  Option descriptions:  * &#x60;asc&#x60; - Sort the results in ascending order.  * &#x60;desc&#x60; - Sort the results in descending order. 
func (r ApiGetShowcasesAlt1Request) Direction(direction string) ApiGetShowcasesAlt1Request {
	r.direction = &direction
	return r
}

// The page number of the results to show.
func (r ApiGetShowcasesAlt1Request) Page(page float32) ApiGetShowcasesAlt1Request {
	r.page = &page
	return r
}

// The number of items to show on each page of results, up to a maximum of 100.
func (r ApiGetShowcasesAlt1Request) PerPage(perPage float32) ApiGetShowcasesAlt1Request {
	r.perPage = &perPage
	return r
}

// The search query to use to filter the results.
func (r ApiGetShowcasesAlt1Request) Query(query string) ApiGetShowcasesAlt1Request {
	r.query = &query
	return r
}

// The way to sort the results.  Option descriptions:  * &#x60;alphabetical&#x60; - Sort the results alphabetically.  * &#x60;date&#x60; - Sort the results by date of creation.  * &#x60;duration&#x60; - Sort the results by duration.  * &#x60;videos&#x60; - Sort the results by the number of videos. 
func (r ApiGetShowcasesAlt1Request) Sort(sort string) ApiGetShowcasesAlt1Request {
	r.sort = &sort
	return r
}

func (r ApiGetShowcasesAlt1Request) Execute() ([]Album, *http.Response, error) {
	return r.ApiService.GetShowcasesAlt1Execute(r)
}

/*
GetShowcasesAlt1 Get all the showcases that belong to the user

This method returns every showcase belonging to the authenticated user.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetShowcasesAlt1Request
*/
func (a *ShowcasesEssentialsAPIService) GetShowcasesAlt1(ctx context.Context) ApiGetShowcasesAlt1Request {
	return ApiGetShowcasesAlt1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []Album
func (a *ShowcasesEssentialsAPIService) GetShowcasesAlt1Execute(r ApiGetShowcasesAlt1Request) ([]Album, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Album
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ShowcasesEssentialsAPIService.GetShowcasesAlt1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/albums"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.direction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "direction", r.direction, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.perPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "per_page", r.perPage, "")
	}
	if r.query != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "query", r.query, "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v LegacyError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateShowcasesRequest struct {
	ctx context.Context
	ApiService ShowcasesEssentialsAPI
	userId int32
	albumItemUris *string
	albumUris *string
}

// A comma-separated list of video or event URIs.
func (r ApiUpdateShowcasesRequest) AlbumItemUris(albumItemUris string) ApiUpdateShowcasesRequest {
	r.albumItemUris = &albumItemUris
	return r
}

// A comma-separated list of showcase URIs.
func (r ApiUpdateShowcasesRequest) AlbumUris(albumUris string) ApiUpdateShowcasesRequest {
	r.albumUris = &albumUris
	return r
}

func (r ApiUpdateShowcasesRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateShowcasesExecute(r)
}

/*
UpdateShowcases Add videos and live events to showcases

This method adds videos and events to the specified showcases. The authenticated user must either be the owner of the showcase or have team permissions.

The present setup permits only one event per showcase.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId The ID of the user.
 @return ApiUpdateShowcasesRequest
*/
func (a *ShowcasesEssentialsAPIService) UpdateShowcases(ctx context.Context, userId int32) ApiUpdateShowcasesRequest {
	return ApiUpdateShowcasesRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
	}
}

// Execute executes the request
func (a *ShowcasesEssentialsAPIService) UpdateShowcasesExecute(r ApiUpdateShowcasesRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ShowcasesEssentialsAPIService.UpdateShowcases")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_id}/albums"
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.albumItemUris == nil {
		return nil, reportError("albumItemUris is required and must be specified")
	}
	if r.albumUris == nil {
		return nil, reportError("albumUris is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "album_item_uris", r.albumItemUris, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "album_uris", r.albumUris, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
