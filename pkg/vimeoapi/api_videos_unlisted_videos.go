/*
Vimeo API

Build something great. Vimeo's API supports flexible, high-quality video integration with your custom apps.

API version: 3.4
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package vimeoapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)

type VideosUnlistedVideosAPI interface {

	/*
		AddVideoPrivacyUser Permit a single user to access an unlisted video

		This method gives a single user permission to access the specified unlisted video. The authenticated user must be the owner of the video.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param userId The ID of the user.
		@param videoId The ID of the video.
		@return ApiAddVideoPrivacyUserRequest
	*/
	AddVideoPrivacyUser(ctx context.Context, userId int32, videoId int32) ApiAddVideoPrivacyUserRequest

	// AddVideoPrivacyUserExecute executes the request
	//  @return User
	AddVideoPrivacyUserExecute(r ApiAddVideoPrivacyUserRequest) (*User, *http.Response, error)

	/*
		AddVideoPrivacyUsers Permit a list of users to access an unlisted video

		This method gives multiple users permission to access the specified unlisted video. The authenticated user must be the owner of the video. The body of the request should follow our [batch request format](https://developer.vimeo.com/api/common-formats#working-with-batch-requests): each object must contain a single **uri** field whose value is the URI of the user who can access the video.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param videoId The ID of the video.
		@return ApiAddVideoPrivacyUsersRequest
	*/
	AddVideoPrivacyUsers(ctx context.Context, videoId int32) ApiAddVideoPrivacyUsersRequest

	// AddVideoPrivacyUsersExecute executes the request
	//  @return []User
	AddVideoPrivacyUsersExecute(r ApiAddVideoPrivacyUsersRequest) ([]User, *http.Response, error)

	/*
		AddVideoPrivacyUsersAlt1 Permit a list of users to access an unlisted video

		This method gives multiple users permission to access the specified unlisted video. The authenticated user must be the owner of the video. The body of the request should follow our [batch request format](https://developer.vimeo.com/api/common-formats#working-with-batch-requests): each object must contain a single **uri** field whose value is the URI of the user who can access the video.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param channelId The ID of the channel.
		@param videoId The ID of the video.
		@return ApiAddVideoPrivacyUsersAlt1Request
	*/
	AddVideoPrivacyUsersAlt1(ctx context.Context, channelId float32, videoId int32) ApiAddVideoPrivacyUsersAlt1Request

	// AddVideoPrivacyUsersAlt1Execute executes the request
	//  @return []User
	AddVideoPrivacyUsersAlt1Execute(r ApiAddVideoPrivacyUsersAlt1Request) ([]User, *http.Response, error)

	/*
		DeleteVideoPrivacyUser Restrict a user from viewing an unlisted video

		This method prevents a user from being able to view the specified unlisted video. The authenticated user must be the owner of the video.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param userId The ID of the user.
		@param videoId The ID of the video.
		@return ApiDeleteVideoPrivacyUserRequest
	*/
	DeleteVideoPrivacyUser(ctx context.Context, userId int32, videoId int32) ApiDeleteVideoPrivacyUserRequest

	// DeleteVideoPrivacyUserExecute executes the request
	DeleteVideoPrivacyUserExecute(r ApiDeleteVideoPrivacyUserRequest) (*http.Response, error)

	/*
		GetVideoPrivacyUsers Get the users who can access an unlisted video

		This method returns every user who has access to the specified unlisted video.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param videoId The ID of the video.
		@return ApiGetVideoPrivacyUsersRequest
	*/
	GetVideoPrivacyUsers(ctx context.Context, videoId int32) ApiGetVideoPrivacyUsersRequest

	// GetVideoPrivacyUsersExecute executes the request
	//  @return []User
	GetVideoPrivacyUsersExecute(r ApiGetVideoPrivacyUsersRequest) ([]User, *http.Response, error)

	/*
		GetVideoPrivacyUsersAlt1 Get the users who can access an unlisted video

		This method returns every user who has access to the specified unlisted video.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param channelId The ID of the channel.
		@param videoId The ID of the video.
		@return ApiGetVideoPrivacyUsersAlt1Request
	*/
	GetVideoPrivacyUsersAlt1(ctx context.Context, channelId float32, videoId int32) ApiGetVideoPrivacyUsersAlt1Request

	// GetVideoPrivacyUsersAlt1Execute executes the request
	//  @return []User
	GetVideoPrivacyUsersAlt1Execute(r ApiGetVideoPrivacyUsersAlt1Request) ([]User, *http.Response, error)
}

// VideosUnlistedVideosAPIService VideosUnlistedVideosAPI service
type VideosUnlistedVideosAPIService service

type ApiAddVideoPrivacyUserRequest struct {
	ctx        context.Context
	ApiService VideosUnlistedVideosAPI
	userId     int32
	videoId    int32
}

func (r ApiAddVideoPrivacyUserRequest) Execute() (*User, *http.Response, error) {
	return r.ApiService.AddVideoPrivacyUserExecute(r)
}

/*
AddVideoPrivacyUser Permit a single user to access an unlisted video

This method gives a single user permission to access the specified unlisted video. The authenticated user must be the owner of the video.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userId The ID of the user.
	@param videoId The ID of the video.
	@return ApiAddVideoPrivacyUserRequest
*/
func (a *VideosUnlistedVideosAPIService) AddVideoPrivacyUser(ctx context.Context, userId int32, videoId int32) ApiAddVideoPrivacyUserRequest {
	return ApiAddVideoPrivacyUserRequest{
		ApiService: a,
		ctx:        ctx,
		userId:     userId,
		videoId:    videoId,
	}
}

// Execute executes the request
//
//	@return User
func (a *VideosUnlistedVideosAPIService) AddVideoPrivacyUserExecute(r ApiAddVideoPrivacyUserRequest) (*User, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *User
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VideosUnlistedVideosAPIService.AddVideoPrivacyUser")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/videos/{video_id}/privacy/users/{user_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"video_id"+"}", url.PathEscape(parameterValueToString(r.videoId, "videoId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.vimeo.user+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v LegacyError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAddVideoPrivacyUsersRequest struct {
	ctx        context.Context
	ApiService VideosUnlistedVideosAPI
	videoId    int32
}

func (r ApiAddVideoPrivacyUsersRequest) Execute() ([]User, *http.Response, error) {
	return r.ApiService.AddVideoPrivacyUsersExecute(r)
}

/*
AddVideoPrivacyUsers Permit a list of users to access an unlisted video

This method gives multiple users permission to access the specified unlisted video. The authenticated user must be the owner of the video. The body of the request should follow our [batch request format](https://developer.vimeo.com/api/common-formats#working-with-batch-requests): each object must contain a single **uri** field whose value is the URI of the user who can access the video.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param videoId The ID of the video.
	@return ApiAddVideoPrivacyUsersRequest
*/
func (a *VideosUnlistedVideosAPIService) AddVideoPrivacyUsers(ctx context.Context, videoId int32) ApiAddVideoPrivacyUsersRequest {
	return ApiAddVideoPrivacyUsersRequest{
		ApiService: a,
		ctx:        ctx,
		videoId:    videoId,
	}
}

// Execute executes the request
//
//	@return []User
func (a *VideosUnlistedVideosAPIService) AddVideoPrivacyUsersExecute(r ApiAddVideoPrivacyUsersRequest) ([]User, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []User
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VideosUnlistedVideosAPIService.AddVideoPrivacyUsers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/videos/{video_id}/privacy/users"
	localVarPath = strings.Replace(localVarPath, "{"+"video_id"+"}", url.PathEscape(parameterValueToString(r.videoId, "videoId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.vimeo.user+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAddVideoPrivacyUsersAlt1Request struct {
	ctx        context.Context
	ApiService VideosUnlistedVideosAPI
	channelId  float32
	videoId    int32
}

func (r ApiAddVideoPrivacyUsersAlt1Request) Execute() ([]User, *http.Response, error) {
	return r.ApiService.AddVideoPrivacyUsersAlt1Execute(r)
}

/*
AddVideoPrivacyUsersAlt1 Permit a list of users to access an unlisted video

This method gives multiple users permission to access the specified unlisted video. The authenticated user must be the owner of the video. The body of the request should follow our [batch request format](https://developer.vimeo.com/api/common-formats#working-with-batch-requests): each object must contain a single **uri** field whose value is the URI of the user who can access the video.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param channelId The ID of the channel.
	@param videoId The ID of the video.
	@return ApiAddVideoPrivacyUsersAlt1Request
*/
func (a *VideosUnlistedVideosAPIService) AddVideoPrivacyUsersAlt1(ctx context.Context, channelId float32, videoId int32) ApiAddVideoPrivacyUsersAlt1Request {
	return ApiAddVideoPrivacyUsersAlt1Request{
		ApiService: a,
		ctx:        ctx,
		channelId:  channelId,
		videoId:    videoId,
	}
}

// Execute executes the request
//
//	@return []User
func (a *VideosUnlistedVideosAPIService) AddVideoPrivacyUsersAlt1Execute(r ApiAddVideoPrivacyUsersAlt1Request) ([]User, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []User
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VideosUnlistedVideosAPIService.AddVideoPrivacyUsersAlt1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/{channel_id}/videos/{video_id}/privacy/users"
	localVarPath = strings.Replace(localVarPath, "{"+"channel_id"+"}", url.PathEscape(parameterValueToString(r.channelId, "channelId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"video_id"+"}", url.PathEscape(parameterValueToString(r.videoId, "videoId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.vimeo.user+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteVideoPrivacyUserRequest struct {
	ctx        context.Context
	ApiService VideosUnlistedVideosAPI
	userId     int32
	videoId    int32
}

func (r ApiDeleteVideoPrivacyUserRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteVideoPrivacyUserExecute(r)
}

/*
DeleteVideoPrivacyUser Restrict a user from viewing an unlisted video

This method prevents a user from being able to view the specified unlisted video. The authenticated user must be the owner of the video.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userId The ID of the user.
	@param videoId The ID of the video.
	@return ApiDeleteVideoPrivacyUserRequest
*/
func (a *VideosUnlistedVideosAPIService) DeleteVideoPrivacyUser(ctx context.Context, userId int32, videoId int32) ApiDeleteVideoPrivacyUserRequest {
	return ApiDeleteVideoPrivacyUserRequest{
		ApiService: a,
		ctx:        ctx,
		userId:     userId,
		videoId:    videoId,
	}
}

// Execute executes the request
func (a *VideosUnlistedVideosAPIService) DeleteVideoPrivacyUserExecute(r ApiDeleteVideoPrivacyUserRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VideosUnlistedVideosAPIService.DeleteVideoPrivacyUser")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/videos/{video_id}/privacy/users/{user_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"video_id"+"}", url.PathEscape(parameterValueToString(r.videoId, "videoId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v LegacyError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v LegacyError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetVideoPrivacyUsersRequest struct {
	ctx        context.Context
	ApiService VideosUnlistedVideosAPI
	videoId    int32
	page       *float32
	perPage    *float32
}

// The page number of the results to show.
func (r ApiGetVideoPrivacyUsersRequest) Page(page float32) ApiGetVideoPrivacyUsersRequest {
	r.page = &page
	return r
}

// The number of items to show on each page of results, up to a maximum of 100.
func (r ApiGetVideoPrivacyUsersRequest) PerPage(perPage float32) ApiGetVideoPrivacyUsersRequest {
	r.perPage = &perPage
	return r
}

func (r ApiGetVideoPrivacyUsersRequest) Execute() ([]User, *http.Response, error) {
	return r.ApiService.GetVideoPrivacyUsersExecute(r)
}

/*
GetVideoPrivacyUsers Get the users who can access an unlisted video

This method returns every user who has access to the specified unlisted video.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param videoId The ID of the video.
	@return ApiGetVideoPrivacyUsersRequest
*/
func (a *VideosUnlistedVideosAPIService) GetVideoPrivacyUsers(ctx context.Context, videoId int32) ApiGetVideoPrivacyUsersRequest {
	return ApiGetVideoPrivacyUsersRequest{
		ApiService: a,
		ctx:        ctx,
		videoId:    videoId,
	}
}

// Execute executes the request
//
//	@return []User
func (a *VideosUnlistedVideosAPIService) GetVideoPrivacyUsersExecute(r ApiGetVideoPrivacyUsersRequest) ([]User, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []User
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VideosUnlistedVideosAPIService.GetVideoPrivacyUsers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/videos/{video_id}/privacy/users"
	localVarPath = strings.Replace(localVarPath, "{"+"video_id"+"}", url.PathEscape(parameterValueToString(r.videoId, "videoId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.perPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "per_page", r.perPage, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.vimeo.user+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v LegacyError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetVideoPrivacyUsersAlt1Request struct {
	ctx        context.Context
	ApiService VideosUnlistedVideosAPI
	channelId  float32
	videoId    int32
	page       *float32
	perPage    *float32
}

// The page number of the results to show.
func (r ApiGetVideoPrivacyUsersAlt1Request) Page(page float32) ApiGetVideoPrivacyUsersAlt1Request {
	r.page = &page
	return r
}

// The number of items to show on each page of results, up to a maximum of 100.
func (r ApiGetVideoPrivacyUsersAlt1Request) PerPage(perPage float32) ApiGetVideoPrivacyUsersAlt1Request {
	r.perPage = &perPage
	return r
}

func (r ApiGetVideoPrivacyUsersAlt1Request) Execute() ([]User, *http.Response, error) {
	return r.ApiService.GetVideoPrivacyUsersAlt1Execute(r)
}

/*
GetVideoPrivacyUsersAlt1 Get the users who can access an unlisted video

This method returns every user who has access to the specified unlisted video.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param channelId The ID of the channel.
	@param videoId The ID of the video.
	@return ApiGetVideoPrivacyUsersAlt1Request
*/
func (a *VideosUnlistedVideosAPIService) GetVideoPrivacyUsersAlt1(ctx context.Context, channelId float32, videoId int32) ApiGetVideoPrivacyUsersAlt1Request {
	return ApiGetVideoPrivacyUsersAlt1Request{
		ApiService: a,
		ctx:        ctx,
		channelId:  channelId,
		videoId:    videoId,
	}
}

// Execute executes the request
//
//	@return []User
func (a *VideosUnlistedVideosAPIService) GetVideoPrivacyUsersAlt1Execute(r ApiGetVideoPrivacyUsersAlt1Request) ([]User, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []User
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VideosUnlistedVideosAPIService.GetVideoPrivacyUsersAlt1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/channels/{channel_id}/videos/{video_id}/privacy/users"
	localVarPath = strings.Replace(localVarPath, "{"+"channel_id"+"}", url.PathEscape(parameterValueToString(r.channelId, "channelId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"video_id"+"}", url.PathEscape(parameterValueToString(r.videoId, "videoId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.perPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "per_page", r.perPage, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.vimeo.user+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v LegacyError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
