/*
Vimeo API

Build something great. Vimeo's API supports flexible, high-quality video integration with your custom apps.

API version: 3.4
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package vimeoapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)

type VideosLiveM3U8PlaybackAPI interface {

	/*
		GetOneTimeEventM3u8Playback Get an M3U8 playback URL for a one-time live event

		This method returns an M3U8 playback URL for the specified event stream. You should use this endpoint only in conjunction with our recommended procedure for playing events via HLS. For more information, see our [HLS guide](https://developer.vimeo.com/api/live/playback).

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param userId The ID of the user.
		@param videoId The ID of the video.
		@return ApiGetOneTimeEventM3u8PlaybackRequest
	*/
	GetOneTimeEventM3u8Playback(ctx context.Context, userId int32, videoId int32) ApiGetOneTimeEventM3u8PlaybackRequest

	// GetOneTimeEventM3u8PlaybackExecute executes the request
	GetOneTimeEventM3u8PlaybackExecute(r ApiGetOneTimeEventM3u8PlaybackRequest) (*http.Response, error)

	/*
		GetOneTimeEventM3u8PlaybackAlt1 Get an M3U8 playback URL for a one-time live event

		This method returns an M3U8 playback URL for the specified event stream. You should use this endpoint only in conjunction with our recommended procedure for playing events via HLS. For more information, see our [HLS guide](https://developer.vimeo.com/api/live/playback).

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param videoId The ID of the video.
		@return ApiGetOneTimeEventM3u8PlaybackAlt1Request
	*/
	GetOneTimeEventM3u8PlaybackAlt1(ctx context.Context, videoId int32) ApiGetOneTimeEventM3u8PlaybackAlt1Request

	// GetOneTimeEventM3u8PlaybackAlt1Execute executes the request
	GetOneTimeEventM3u8PlaybackAlt1Execute(r ApiGetOneTimeEventM3u8PlaybackAlt1Request) (*http.Response, error)
}

// VideosLiveM3U8PlaybackAPIService VideosLiveM3U8PlaybackAPI service
type VideosLiveM3U8PlaybackAPIService service

type ApiGetOneTimeEventM3u8PlaybackRequest struct {
	ctx        context.Context
	ApiService VideosLiveM3U8PlaybackAPI
	userId     int32
	videoId    int32
}

func (r ApiGetOneTimeEventM3u8PlaybackRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetOneTimeEventM3u8PlaybackExecute(r)
}

/*
GetOneTimeEventM3u8Playback Get an M3U8 playback URL for a one-time live event

This method returns an M3U8 playback URL for the specified event stream. You should use this endpoint only in conjunction with our recommended procedure for playing events via HLS. For more information, see our [HLS guide](https://developer.vimeo.com/api/live/playback).

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userId The ID of the user.
	@param videoId The ID of the video.
	@return ApiGetOneTimeEventM3u8PlaybackRequest
*/
func (a *VideosLiveM3U8PlaybackAPIService) GetOneTimeEventM3u8Playback(ctx context.Context, userId int32, videoId int32) ApiGetOneTimeEventM3u8PlaybackRequest {
	return ApiGetOneTimeEventM3u8PlaybackRequest{
		ApiService: a,
		ctx:        ctx,
		userId:     userId,
		videoId:    videoId,
	}
}

// Execute executes the request
func (a *VideosLiveM3U8PlaybackAPIService) GetOneTimeEventM3u8PlaybackExecute(r ApiGetOneTimeEventM3u8PlaybackRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VideosLiveM3U8PlaybackAPIService.GetOneTimeEventM3u8Playback")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_id}/videos/{video_id}/m3u8_playback"
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"video_id"+"}", url.PathEscape(parameterValueToString(r.videoId, "videoId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetOneTimeEventM3u8PlaybackAlt1Request struct {
	ctx        context.Context
	ApiService VideosLiveM3U8PlaybackAPI
	videoId    int32
}

func (r ApiGetOneTimeEventM3u8PlaybackAlt1Request) Execute() (*http.Response, error) {
	return r.ApiService.GetOneTimeEventM3u8PlaybackAlt1Execute(r)
}

/*
GetOneTimeEventM3u8PlaybackAlt1 Get an M3U8 playback URL for a one-time live event

This method returns an M3U8 playback URL for the specified event stream. You should use this endpoint only in conjunction with our recommended procedure for playing events via HLS. For more information, see our [HLS guide](https://developer.vimeo.com/api/live/playback).

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param videoId The ID of the video.
	@return ApiGetOneTimeEventM3u8PlaybackAlt1Request
*/
func (a *VideosLiveM3U8PlaybackAPIService) GetOneTimeEventM3u8PlaybackAlt1(ctx context.Context, videoId int32) ApiGetOneTimeEventM3u8PlaybackAlt1Request {
	return ApiGetOneTimeEventM3u8PlaybackAlt1Request{
		ApiService: a,
		ctx:        ctx,
		videoId:    videoId,
	}
}

// Execute executes the request
func (a *VideosLiveM3U8PlaybackAPIService) GetOneTimeEventM3u8PlaybackAlt1Execute(r ApiGetOneTimeEventM3u8PlaybackAlt1Request) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VideosLiveM3U8PlaybackAPIService.GetOneTimeEventM3u8PlaybackAlt1")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/videos/{video_id}/m3u8_playback"
	localVarPath = strings.Replace(localVarPath, "{"+"video_id"+"}", url.PathEscape(parameterValueToString(r.videoId, "videoId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
